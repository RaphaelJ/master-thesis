# Event-driven network applications

*Rusty* interacts with the application layer through an event-driven interface.
Basically, the application layer provides functions to handle events such as a
new incoming connection (on a listening *TCP* port), a new arrival of data on
an established connection, or the closing of a connection. It then reacts to
these events, by doing actions such as requesting to send data or to close a
connection.

In this chapter, you will be presented how to write a simple multi-threaded
echo server. The application accepts new connections on a listening socket and
echoes back data received on established connections.

## Closures

In this chapter, we will use a new *C++* feature introduced in the 2011 revision
of the language: closures.

## Initializing the network stack

The first step is to initialize the network stack. This is done by initializing
the lower layer of the network stack, namely the abstraction layer over the
network driver.

Three parameters must be supplied:

* The interface and its associated *IPv4* address on which the stack will run.
  In this example, we use the `xgbe1` 10 Gbps Ethernet interface. The *ARP*
  layer  will announce the address, and outgoing *IPv4* datagrams will be
  delivered  from this address.
* The number of cores that *Rusty* will use to run this network stack. Here we
  chose to use 35 cores of the *TILE-Gx36* device. We can not use more than 35
  cores on this 36-core device, as *Rusty* takes total execution control of
  these cores, and as at least one core must be left free for the operating
  system to run.

This following call constructs a `stack` object using the `mpipe_t` network
driver (*mPIPE* is the name of the driver provided by *Tilera* for its NICs).
The call only allocates resources and initializes the network driver. It does 
not actually start the network stack.

```C++
rusty::driver::mpipe_t stack("xgbe1", "10.0.2.1", 35);
```

> **Note**
> If we wished to use several network interfaces, we would have created several 
> `stack` objects, one per interface.

## Adds a listening port

We would like to echo data coming on incoming connections on port 22.

First, we need to open the port for new connections. To do that, we call the
`tcp_listen()` method on the previously initialized `stack` object. In addition
to the port on which the stack must listen, the method accepts a function that
will be called each time an new connection is established. Let's call
`tcp_listen()` to listen on port 22 with a function that we will define later:

```C++
stack.tcp_listen(22, new_connection_handler);
```

## Handle connection events

The `new_connection_handler` function, the one we did not defined yet, musts
accept a connection as argument (as a `cont_t` value) and must return a
`conn_handlers_t` value containing a set of handlers for this connection.

The `conn_handlers_t` data-type contains four function pointers, each one
handling one type of event that happens on an established connection:

```C++
struct conn_handlers_t {
    // Called when the connection receives new data.
    function<void(cursor_t)>                new_data;

    // Called when the remote asked to close the connection.
    function<void()>                        remote_close;

    // Called when both ends closed the connection. Resources allocated for
    // the connection should be released.
    function<void()>                        close;

    // The connection has been unexpectedly closed (connection reset).
    // Resources allocated for the connection should be released.
    function<void()>                        reset;
};
```

```C++
conn_handlers_t new_connection_handler(conn_t conn)
{
    conn_handlers_t handlers;

    handlers.new_data =
        [conn](cursor_t in) mutable
        {
            size_t size = in.size();

            conn.send(
                size,
                [in](size_t offset, cursor_t out)
                {
                    out.write(in.drop(offset).take(out.size()));
                },
                do_nothing // Does nothing on acknowledgment
            );
        };


    handlers.remote_close =
        [conn]() mutable
        {
            // Closes when the remote closes the connection.
            conn.close();
        };

    handlers.close = do_nothing;
    handlers.reset = do_nothing;

    return handlers;
}
```
