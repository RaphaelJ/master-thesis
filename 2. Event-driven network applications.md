# Event-driven network applications

*Rusty* interacts with the application layer through an event-driven interface.
Basically, the application layer provides functions to handle events such as a
new incoming connection (on a listening *TCP* port), a new arrival of data on
an established connection, or the closing of a connection. It then reacts to
these events, by doing actions such as requesting to send data or to close a
connection.

In this chapter, you will be presented how to write a simple multi-threaded
echo server. The application accepts new connections on a listening socket and
echoes back data received on established connections.

## Initializing the network stack

The first step is to initialize the network stack. This is done by initializing
the lower layer of the network stack, namely the abstraction layer over the
network driver.

Three parameters must be supplied:

* The interface and its associated *IPv4* address on which the stack will run.
  In this example, we use the `xgbe1` 10 Gbps Ethernet interface. The *ARP*
  layer  will announce the address, and outgoing *IPv4* datagrams will be
  delivered  from this address.
* The number of cores that *Rusty* will use to run this network stack. Here we
  chose to use 35 cores of the *TILE-Gx36* device. We can not use more than 35
  cores on this 36-core device, as *Rusty* takes total execution control of
  these cores, and as at least one core must be left free for the operating
  system to run.

This following call constructs a `stack` object using the `mpipe_t` network
driver (*mPIPE* is the name of the driver provided by *Tilera* for its NICs).
The call only allocates resources and initializes the network driver. It does 
not actually start the network stack.

```C++
rusty::driver::mpipe_t stack("xgbe1", "10.0.2.1", 35);
```

> **Note**
> If we wished to use several network interfaces, we would have created several 
> `stack` objects, one per interface.

## Adds a listening port

We would like to echo data coming on connections established on port 22. To do
that, we must call the `tcp_listen` method on the previously initialized `stack`
object. 

```C++
stack.tcp_listen(22, new_connection_handler);
```
